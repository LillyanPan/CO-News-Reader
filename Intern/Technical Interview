Hash Tables

store key in hashtable to know what key is held
chaining: array of linked lists
linear / quadratic probiing: steping through array to open space; advantage linear: locality
	advantage quad: avoid clustering
	Can have 2 different contains: contains key or value (value iterate through every element 	in table and compare)

Example
Find # of common characters between two strings containing any Unicode char

	If there are duplicates in strings does that count as one or +?
	Include empty string?
	O(mn)- note, hashset only takes generics not primitive types


Strings and Arrays

OO interviews ask about inheritance: how do you put different objects into same array if they are all inherit from certian superclass

Example
1. Determine if a string is a palindrome
2. Write a function num_needed: str --> int that returns min num of char to add to the end of the word to make it a palindrome
	loop through str
		if substring is palindrome
		return index (this is also num of char)
Instead can use pointers to save time


Linked Lists

Circularly linked list: when are you at the beginning in a circularly LL?
Can add by just adding to most recently contained; can touch less things

1. Implement a Node class to rep a LL: class needs data and next pointer
2. Find the n-th to last element in a singly-lined list
	2.1 Is the list circular?
	2.2 Do you know that n is smaller than the length of the list (valid inputs)
	First check if list is null
	2.3 Returning element or ...?

	Two pointers: move up one pointer n positions. Inc until 2nd pointer hits null


Stacks and Queues

Stack: DFS
Queus: BFS

1. Data structure for a stack and queue: LL
	Stack (LIFO)
		-Node head
		-tail tail // Keep track of tail for queue is best
		push(value)
			Node new_n = new Node()
			new_n.value = value
			new_node.next = head
			head = new_node
			Corner case: tail = new.node; if stack is empty
		pop()
			check null // What behavior should it be if null/empty
			Node cur = head;
			head = cur.next;
			return cur;

2. Implement a queue with two stacks. Implement a stack with two queues
	add(): add to first stack
	pop(): pop off first element of stack 2
		if stack2 isEmpty()
		if stack1 isEmpty() //Check if both stacks are empty
			while (stack1.isEmpty())
				stack2.push(stack1.pop())
		return stack2.pop() 

Trees

1. Write code for the inorder. preoder, and postorder traversals of BST
	post(n)
	 post(n.left)
	 post(n.right)
	 f(n)
2. Print only nodes along the perimeter of a binary tree
	print left and right most leaves of each layer
	OR pring left side, leaves, right side
	Discuss with interviewer

	Write one fxn that prints left, one the prints right, etc.
	printLeftPath(n){
		// check n is valid
		print (n.data)
		if n.left
			print printLeftPath(n)
		if n.right
			print printLeftPath(n)

	printLeaves(n)
		pre(n)
			if (n.left==null)
				n.right==null
					print(n.data)
	use preorder left most leaf will print before right
	check that printLeftPath, etc doesn't duplicate print
	if (!(n.left -- null&n.right==null)


Graphs

1. Path b/w two nodes
	Ask adj list or matrix?
	Don't visit the same node twice (boolean flag)

	while (!q.isEmpty())
		a = q.dequeue (check if neighbors are destination)

	Check if source and destination are the same; check at begining


Sorting Algorithms

	Mergesort: divide and recurse- safer choice
	Quicksort: chose pivot and move left or right of pivot
		worst case: n^2 if in reverse order
	In general ask if data is sorted or not -- can use building in library sort


Miscellaneous

	Run time/space complex of your own algs
	Compare Java vs. C++
	Optimize database to op certian queries
